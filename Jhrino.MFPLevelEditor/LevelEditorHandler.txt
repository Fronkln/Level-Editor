using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using UnityEngine;
using UnityEngine.Networking;
using UnityEngine.PostProcessing;
using UnityEngine.UI;

namespace Jhrino.MFPLevelEditor
{
	// Token: 0x020000E1 RID: 225
	public class LevelEditorHandler : MonoBehaviour
	{


		// Token: 0x06000615 RID: 1557
		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.P))
			{
				this.PlayMode();
				this.PrototypeSave();
			}
			if (Input.GetKeyDown(KeyCode.N) && !this.PlayMod)
			{
				this.PrototypeLoad();
			}
			if (Input.GetKeyDown(KeyCode.M) && !this.PlayMod)
			{
				this.PrototypeSave();
			}
			if(this.Editing && Input.GetKeyDown(KeyCode.X))
				ExitEditMode();

			if (this.PlayMod)
			{
				LevelEditorHandler.levelTimer += Time.timeScale;
				if ((double)this.Player.GetComponent<PlayerScript>().health < 0.02)
				{
					LevelEditorHandler.PlayerisDeadAndForceAutoLoad = true;
				}
			}
			if (!this.PlayMod)
			{
				if (this.Editing)
				{
					this.EditingMode();
				}
				RaycastHit raycastHit;
				if (Input.GetMouseButtonDown(0) && !this.Editing && !SnapToBuild && !this.adjustingSettings && Physics.Raycast(this.EditorCamera.ScreenPointToRay(Input.mousePosition), out raycastHit))
				{
					if(raycastHit.transform.gameObject != null)
					{
					MFPEditorLogger.Log("Entering edit mode to object " + raycastHit.transform.name);
					this.EnterEditMode(raycastHit.transform.gameObject);
					}
				}
				if (Input.GetKeyDown(KeyCode.T) && !this.Editing)
				{
					if(!SnapToBuild)
					{
					SnapToBuild = true;
						if(Editing)
							ExitEditMode();
						ToggleSnapping(true);
					}
					else
					{
						SnapToBuild = false;
						ToggleSnapping(false);

					}

				}
				if (Input.GetKeyDown(KeyCode.K) && !this.Editing)
				{
					GameObject gameObject2 = GameObject.CreatePrimitive(PrimitiveType.Sphere);
					UnityEngine.Object.Destroy(gameObject2.GetComponent<SphereCollider>());
					gameObject2.AddComponent<CapsuleCollider>();
					gameObject2.layer = 8;
					gameObject2.transform.localScale = new Vector3(gameObject2.transform.localScale.x, 4f, gameObject2.transform.localScale.x);
					gameObject2.transform.position = new Vector3(this.EditorCamera.transform.position.x, this.EditorCamera.transform.position.y, -0.1f);
					gameObject2.GetComponent<MeshRenderer>().material.color = new Color(1f, 0f, 0f);
					this.EnemySpawnpoints.Add(gameObject2.transform);
					this.EnterEditMode(gameObject2);
				}


				if(!PlayMod && SnapToBuild)
				{
					RaycastHit hit;
					Ray ray = EditorCamera.GetComponent<Camera>().ScreenPointToRay(Input.mousePosition);

					if(Physics.Raycast(ray, out hit))
					{
						if(hit.transform.GetComponent<snaphelper>());
						{
							SnapTarget = hit.transform.gameObject;
							
						
					}

					

						if(Input.GetMouseButtonDown(0))
						{
						if(SnapTarget != null && SnapTarget.GetComponent<snaphelper>().SnappedObject == null)
						{

							if(!SnapTarget.GetComponent<snaphelper>().isWallNode)
							{
							GameObject newFloor = Instantiate(floor_Wood);
							newFloor.SetActive(true);

							 if(SnapTarget.GetComponent<snaphelper>().snapaxis == snaphelper.Axis.NegativeX)
							 newFloor.transform.position = new Vector3(SnapTarget.transform.parent.position.x - 2, SnapTarget.transform.parent.position.y, 0);
							 else
							 newFloor.transform.position = new Vector3(SnapTarget.transform.parent.position.x + 2, SnapTarget.transform.parent.position.y, 0);

							 GeometryFloorLump.Add(newFloor);
							}
							else
							{


								GameObject newWall = Instantiate(this.wall_Brick);
								newWall.transform.name = "Brick Wall #" + GeometryWallLump.Count().ToString();
								newWall.SetActive(true);
							    newWall.transform.position = new Vector3(SnapTarget.transform.position.x, SnapTarget.transform.position.y, SnapTarget.transform.position.z);
								 newWall.transform.eulerAngles = new Vector3(0, -90, 0);

								SnapTarget.GetComponent<snaphelper>().SnappedObject = newWall;
									GeometryWallLump.Add(newWall);
									MFPEditorLogger.Log(newWall.name + " added");
								
							}
							
							SnapTarget = null;
						}
						}
					}
				}



			}
		}

		// Token: 0x06000616 RID: 1558
		public LevelEditorHandler()
		{
		}

		// Token: 0x06000617 RID: 1559
		private void Start()
		{
			this.LoadEditorAssets();
			if (!Directory.Exists(MFPEditorUtils.LoadFileFromDataFolder("default")))
			{
				Directory.CreateDirectory(MFPEditorUtils.LoadFileFromDataFolder("Levels/default"));
			}
			this.root = GameObject.Find("Root").GetComponent<RootScript>();
			UnityEngine.Object.FindObjectOfType<OptimizerScript>().enabled = false;
			this.root.nrOfEnemiesTotal = 0;
			this.HUD = GameObject.Find("HUD/Canvas");
			this.Player = GameObject.Find("Player");
			this.Camera = GameObject.Find("Main Camera");
			this.BackgroundCamera = GameObject.Find("HorizonBackground_Theme_1/Background Camera");
			BackgroundCamera.transform.parent = null;
		//	Destroy(GameObject.Find("HorizonBackground_Theme_1"));

			GameObject LevelLight = new GameObject();	
			LevelLight.name = "Level Lighting";
			LevelLight.transform.eulerAngles = new Vector3(50,-30,0);

			Light SceneLight = LevelLight.AddComponent<Light>();
			SceneLight.type = LightType.Directional;
			SceneLight.renderMode = LightRenderMode.ForcePixel;
			SceneLight.shadows = LightShadows.None;
			SceneLight.color = new Color32(255,244, 214, 255);
			SceneLight.cullingMask = 1 << 8 | 1 << 14;

			SkyColor = Camera.GetComponent<Camera>().backgroundColor;

			this.Player.SetActive(false);
			this.Camera.SetActive(false);
			this.HUD.GetComponentInChildren<Canvas>().enabled = false;
			this.EnemySample = GameObject.Find("New Enemy");
			this.EnemySample.SetActive(false);
			/* OLD BULDING 
			GameObject gameObject = GameObject.CreatePrimitive(PrimitiveType.Cube);
			gameObject.layer = 8;
			gameObject.transform.position = new Vector3(0f, -1f, 0f);
			gameObject.transform.localScale = new Vector3(5f, 1f, 7f);
			gameObject.GetComponent<MeshRenderer>().material.color = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);
			gameObject.AddComponent<TextureTilingController>();
			gameObject.GetComponent<MeshRenderer>().material.mainTexture = this.DefaultTexture;
			gameObject.GetComponent<MeshRenderer>().material.mainTexture.name = "EditorAssets/dev_measuregeneric01b.png";
			gameObject.name = "Brush #1";
			this.BrushLump.Add(gameObject);
			*/

			Material FloorMaterial = new Material(Shader.Find("Standard"));


			FloorMaterial.mainTexture = MFPEditorUtils.LoadPNG(LoadFileFromDataFolder("EditorAssets/BaseGame/textures/floor_wood_indoors.png"));
			FloorMaterial.mainTexture.name = "EditorAssets/BaseGame/textures/floor_wood_indoors.png";
			FloorMaterial.SetTexture("_BumpMap", MFPEditorUtils.LoadPNG(LoadFileFromDataFolder("EditorAssets/BaseGame/Textures/floor_wood_indoors_" + "normal.png")));

			GameObject gameObject = new GameObject();
			gameObject.name = "Wood Floor";
			gameObject.layer = 8;
			MeshRenderer meshrend = gameObject.AddComponent<MeshRenderer>();
			MeshCollider meshColl = gameObject.AddComponent<MeshCollider>();
			MeshFilter meshFilter = gameObject.AddComponent<MeshFilter>();

			meshFilter.mesh = FastObjImporter.Instance.ImportFile(MFPEditorUtils.LoadFileFromDataFolder("EditorAssets/BaseGame/floor_wood.obj"));
			meshColl.sharedMesh = meshFilter.mesh;
			meshrend.material = FloorMaterial;

			GameObject snapBuildLeft = new GameObject();
			snapBuildLeft.name = "SnapBuildLeft";
			snapBuildLeft.transform.parent = gameObject.transform;
			snapBuildLeft.AddComponent<BoxCollider>();
			snapBuildLeft.transform.localScale = new Vector3(0.1963f, 0.73813f, 10.98067f);
			snapBuildLeft.transform.localPosition = new Vector3(-1.09f, -0.1309f, 1.1903f);

			snaphelper snaphelping = snapBuildLeft.AddComponent<snaphelper>();
			snaphelping.snapaxis = snaphelper.Axis.NegativeX;

			GameObject snapBuildRight = new GameObject();
			snapBuildRight.name = "SnapBuildRight";
			snapBuildRight.transform.parent = gameObject.transform;
			snapBuildRight.AddComponent<BoxCollider>();
			snapBuildRight.transform.localScale = new Vector3(0.1963f, 0.73813f, 10.98067f);
			snapBuildRight.transform.localPosition = new Vector3(1.09f, -0.1309f, 1.1903f);

			snaphelper snaphelpingR = snapBuildRight.AddComponent<snaphelper>();
			snaphelpingR.snapaxis = snaphelper.Axis.PositiveX;


			 GameObject SnapBuildMiddle = new GameObject();
			 SnapBuildMiddle.name = "SnapBuildMiddle";
			 SnapBuildMiddle.transform.parent = gameObject.transform;
			 SnapBuildMiddle.AddComponent<BoxCollider>();
			 SnapBuildMiddle.transform.position = new Vector3(0, 2.34f, 6.735f);
			SnapBuildMiddle.transform.localScale = new Vector3(2,5,0.1f);
			 SnapBuildMiddle.AddComponent<snaphelper>().isWallNode = true;

			Destroy(gameObject.GetComponent<snaphelper>());

			GameObject floorwood_asset = Instantiate(gameObject);
			floorwood_asset.SetActive(false);

			floor_Wood = floorwood_asset;

			GeometryFloorLump.Add(gameObject);
			MFPEditorLogger.Log("Wood floor spawned");

			GameObject wall_Brick = new GameObject();
			wall_Brick.name = "Brick Wall";

			wall_Brick.layer = 8;
			MeshRenderer meshrend_brickwall = wall_Brick.AddComponent<MeshRenderer>();
			MeshCollider meshColl_brickwall = wall_Brick.AddComponent<MeshCollider>();
			MeshFilter meshFilter_brickwall = wall_Brick.AddComponent<MeshFilter>();

			meshFilter_brickwall.mesh = FastObjImporter.Instance.ImportFile(MFPEditorUtils.LoadFileFromDataFolder("EditorAssets/BaseGame/wall_brick.obj"));
			meshColl_brickwall.sharedMesh = meshFilter_brickwall.mesh;
			meshrend_brickwall.material = new Material(FloorMaterial);

			meshrend_brickwall.material.mainTexture = MFPEditorUtils.LoadPNG(LoadFileFromDataFolder("EditorAssets/BaseGame/textures/wall_textures_1.png"));
			meshrend_brickwall.material.mainTexture.name = "EditorAssets/BaseGame/textures/wall_textures_1.png";
			meshrend_brickwall.material.SetTexture("_BumpMap", MFPEditorUtils.LoadPNG(LoadFileFromDataFolder("EditorAssets/BaseGame/Textures/wall_textures_1" + "normal" + ".png")));

			MFPEditorLogger.Log("Brick meshes are dealt with");

			GameObject brickwall_SnapBuildLeft = new GameObject();

			MeshFilter meshFilter_SnapBuildLeft = brickwall_SnapBuildLeft.AddComponent<MeshFilter>();
			meshFilter_SnapBuildLeft.mesh = meshFilter_brickwall.mesh;
			MFPEditorLogger.Log("SnapBuildLeft meshes are done");
			brickwall_SnapBuildLeft.AddComponent<MeshRenderer>().material = StandardShaderUtils.ChangeRenderMode(wall_Brick.GetComponent<MeshRenderer>().material, StandardShaderUtils.BlendMode.Transparent);
			brickwall_SnapBuildLeft.GetComponent<MeshRenderer>().material.color = new Color(0,1,0, 0.4f);
			brickwall_SnapBuildLeft.GetComponent<MeshRenderer>().enabled = false;
			MFPEditorLogger.Log("SnapBuildLeft renderer is done");

			brickwall_SnapBuildLeft.transform.parent = wall_Brick.transform;
			brickwall_SnapBuildLeft.AddComponent<BoxCollider>();
			brickwall_SnapBuildLeft.GetComponent<BoxCollider>().size = new Vector3(0.1f, 5, 2);
			brickwall_SnapBuildLeft.transform.position = new Vector3(0,0, -2);
			
			brickwall_SnapBuildLeft.AddComponent<snaphelper>();
			brickwall_SnapBuildLeft.GetComponent<snaphelper>().isWallNode = true;

			MFPEditorLogger.Log("SnapBuildLeft is done");

			GameObject brickwall_SnapBuildRight = new GameObject();

			MeshFilter meshFilter_SnapBuildRight = brickwall_SnapBuildRight.AddComponent<MeshFilter>();
			meshFilter_SnapBuildRight.mesh = meshFilter_brickwall.mesh;
			MFPEditorLogger.Log("SnapBuildRight mesh is done");
			brickwall_SnapBuildRight.AddComponent<MeshRenderer>().enabled = false;
			brickwall_SnapBuildRight.GetComponent<MeshRenderer>().material = brickwall_SnapBuildLeft.GetComponent<MeshRenderer>().material;
			MFPEditorLogger.Log("SnapBuildRight renderer is done");

			brickwall_SnapBuildRight.transform.parent = wall_Brick.transform;
			brickwall_SnapBuildRight.AddComponent<BoxCollider>();
			brickwall_SnapBuildRight.GetComponent<BoxCollider>().size = new Vector3(0.1f, 5, 2);
			brickwall_SnapBuildRight.transform.position = new Vector3(0,0, 2);
			
			brickwall_SnapBuildRight.AddComponent<snaphelper>();
			brickwall_SnapBuildRight.GetComponent<snaphelper>().isWallNode = true;
			MFPEditorLogger.Log("SnapBuildRight is done");


			
			GameObject brickwall_SnapBuildTop = new GameObject();
			
			MeshFilter meshFilter_SnapBuildTop = brickwall_SnapBuildTop.AddComponent<MeshFilter>();
			meshFilter_SnapBuildTop.mesh = meshFilter_brickwall.mesh;
			MFPEditorLogger.Log("SnapBuildTop mesh is done");
			brickwall_SnapBuildTop.AddComponent<MeshRenderer>();
			brickwall_SnapBuildTop.GetComponent<MeshRenderer>().material = brickwall_SnapBuildLeft.GetComponent<MeshRenderer>().material;
			brickwall_SnapBuildTop.GetComponent<MeshRenderer>().enabled = false;
			MFPEditorLogger.Log("SnapBuildTop renderer is done");

			brickwall_SnapBuildTop.transform.parent = wall_Brick.transform;
			brickwall_SnapBuildTop.AddComponent<BoxCollider>();
			brickwall_SnapBuildTop.GetComponent<BoxCollider>().size = new Vector3(0.1f, 5, 2);
			brickwall_SnapBuildTop.transform.position = new Vector3(0,5,0);
			
			brickwall_SnapBuildTop.AddComponent<snaphelper>();
			brickwall_SnapBuildTop.GetComponent<snaphelper>().isWallNode = true;

			MFPEditorLogger.Log("SnapBuildTop is done");

			GameObject brickwall_SnapBuildBottom = new GameObject();


			MeshFilter meshFilter_SnapBuildBottom = brickwall_SnapBuildBottom.AddComponent<MeshFilter>();
			meshFilter_SnapBuildBottom.mesh = meshFilter_brickwall.mesh;
			brickwall_SnapBuildBottom.AddComponent<MeshRenderer>();
			brickwall_SnapBuildBottom.GetComponent<MeshRenderer>().material = brickwall_SnapBuildLeft.GetComponent<MeshRenderer>().material;
			brickwall_SnapBuildBottom.GetComponent<MeshRenderer>().enabled = false;

			brickwall_SnapBuildBottom.transform.parent = wall_Brick.transform;
			brickwall_SnapBuildBottom.AddComponent<BoxCollider>();
			brickwall_SnapBuildBottom.transform.position = new Vector3(0,-5,0);
			
			brickwall_SnapBuildBottom.AddComponent<snaphelper>();
			brickwall_SnapBuildBottom.GetComponent<snaphelper>().isWallNode = true;

			brickwall_SnapBuildLeft.name = "BrickWall_SnapBuildLeft";
			brickwall_SnapBuildTop.name = "BrickWall_SnapBuildTop";
			brickwall_SnapBuildBottom.name = "BrickWall_SnapBuildBottom";
			brickwall_SnapBuildRight.name = "BrickWall_SnapBuildRight";

			this.wall_Brick = wall_Brick;
			this.wall_Brick.SetActive(false);

			
			
			MFPEditorLogger.Log("Snappies are done");



			

			GameObject gameObject2 = new GameObject();
			gameObject2.name = "EditorCamera";
			this.EditorCamera = gameObject2.AddComponent<Camera>();
			this.EditorCamera.gameObject.AddComponent<PostProcessingBehaviour>();
			this.EditorCamera.gameObject.GetComponent<PostProcessingBehaviour>().profile = this.Camera.GetComponent<PostProcessingBehaviour>().profile;
			this.EditorCamera.depth = -1f;
			this.EditorCamera.clearFlags = CameraClearFlags.Depth;
			this.EditorCamera.transform.position = new Vector3(0f, 0f, -3f);
			GameObject gameObject3 = new GameObject();
			gameObject3.transform.position = new Vector3(0f, 0f, -15f);
			CameraMovement cameraMovement = gameObject3.AddComponent<CameraMovement>();
			cameraMovement.normalSpeed = 5f;
			cameraMovement.runSpeed = 5f;
			cameraMovement.doMove = true;
			cameraMovement.crouch = false;
			cameraMovement.cam = gameObject2.transform;
			gameObject2.transform.parent = gameObject3.transform;
			this.SpawnEditorHud();
			LevelEditorHandler.Inst = this;
			GameObject gameObject4 = GameObject.CreatePrimitive(PrimitiveType.Sphere);
			UnityEngine.Object.Destroy(gameObject4.GetComponent<SphereCollider>());
			gameObject4.AddComponent<CapsuleCollider>();
			gameObject4.transform.localScale = new Vector3(gameObject4.transform.localScale.x, 4f, gameObject4.transform.localScale.x);
			gameObject4.name = "PlayerSpawn";
			GameObject gameObject5 = GameObject.CreatePrimitive(PrimitiveType.Cube);
			gameObject5.transform.position = new Vector3(5f, 0f, 0f);
			gameObject5.transform.localScale = new Vector3(1f, 1f, 4f);
			gameObject5.name = "MFPEditor_End_Level";
			gameObject5.AddComponent<LevelChangerScript>();
			gameObject5.GetComponent<MeshRenderer>().material.color = Color.green;
			this.FinishLevelTrigger = gameObject5;
			this.PlayerSpawn = gameObject4.transform;
			this.PlayerSpawn.transform.GetComponent<MeshRenderer>().material.color = new Color(1f, 0.5f, 1f);
			this.PlayerSpawn.transform.position = new Vector3(0f, 1f, 0f);
			this.PlayMod = false;
			List<string> list = new List<string>();
			foreach (Transform transform in UnityEngine.Object.FindObjectsOfType<Transform>())
			{
				list.Add(transform.name);
			}
			if (LevelEditorHandler.PlayerisDeadAndForceAutoLoad)
			{
				this.PrototypeLoad();
				LevelEditorHandler.PlayerisDeadAndForceAutoLoad = false;
			}
			File.WriteAllLines("F:\\steamapps2\\steamapps\\common\\My Friend Pedro\\jhrino_log.txt", list.ToArray());
		}

		// Token: 0x06000618 RID: 1560
		public void ChangeCameraState(LevelEditorHandler.CameraMode state, bool editorCamera)
		{
			if (state != LevelEditorHandler.CameraMode.Disabled)
			{
				if (state != LevelEditorHandler.CameraMode.Enabled)
				{
					return;
				}
				if (!this.EditorCamera)
				{
					this.Camera.GetComponent<Camera>().enabled = true;
					return;
				}
				this.EditorCamera.enabled = true;
				return;
			}
			else
			{
				if (!this.EditorCamera)
				{
					this.Camera.GetComponent<Camera>().enabled = false;
					return;
				}
				this.EditorCamera.enabled = true;
				return;
			}
		}

		// Token: 0x06000619 RID: 1561
		public void SpawnEditorHud()
		{
			GameObject gameObject = new GameObject();
			gameObject.layer = 5;
			gameObject.name = "Canvus";
			RectTransform rectTransform = gameObject.AddComponent<RectTransform>();
			rectTransform.anchorMin = new Vector2(0.5f, 0f);
			rectTransform.anchorMax = new Vector2(0.5f, 0f);
			Canvas canvas = gameObject.AddComponent<Canvas>();
			canvas.renderMode = RenderMode.ScreenSpaceOverlay;
			canvas.pixelPerfect = false;
			canvas.targetDisplay = 0;
			canvas.additionalShaderChannels = AdditionalCanvasShaderChannels.None;
			CanvasScaler canvasScaler = gameObject.AddComponent<CanvasScaler>();
			canvasScaler.uiScaleMode = CanvasScaler.ScaleMode.ScaleWithScreenSize;
			canvasScaler.screenMatchMode = CanvasScaler.ScreenMatchMode.MatchWidthOrHeight;
			canvasScaler.referenceResolution = new Vector2(1920f, 1080f);
			canvasScaler.scaleFactor = 0.5f;
			canvasScaler.referencePixelsPerUnit = 100f;
			gameObject.AddComponent<GraphicRaycaster>().ignoreReversedGraphics = true;
			GameObject gameObject5 = new GameObject();
			gameObject5.transform.parent = gameObject.transform;
			gameObject5.layer = 5;
			gameObject5.AddComponent<RectTransform>();
			gameObject5.GetComponent<RectTransform>().pivot = new Vector2(0.5f, 0.5f);
			gameObject5.GetComponent<RectTransform>().anchorMin = new Vector2(0.5f, 0f);
			gameObject5.GetComponent<RectTransform>().anchorMax = new Vector2(0.5f, 0f);
			Text text = gameObject5.AddComponent<Text>();
			Material material = new Material(Shader.Find("UI/Default"));
			text.material = material;
			text.text = "GAME OVER";
			text.font = (Resources.GetBuiltinResource(typeof(Font), "Arial.ttf") as Font);
			text.fontStyle = FontStyle.Bold;
			text.fontSize = 68;
			text.lineSpacing = 1f;
			text.supportRichText = false;
			text.alignment = TextAnchor.MiddleCenter;
			text.horizontalOverflow = HorizontalWrapMode.Overflow;
			text.verticalOverflow = VerticalWrapMode.Overflow;
			text.resizeTextForBestFit = false;
			text.alignByGeometry = false;
			text.GetComponent<RectTransform>().sizeDelta = new Vector2(472.9f, 100f);
			this.DebugObject = text;
			gameObject5.GetComponent<RectTransform>().anchoredPosition = new Vector2(-45.6f, 83f);
			new GameObject();

			GameObject gameObject2 = new GameObject();
			gameObject2.name = "CoordinateField";
			gameObject2.AddComponent<RectTransform>();
			gameObject2.transform.parent = gameObject.transform;
			gameObject2.layer = 5;
			gameObject2.AddComponent<RectTransform>();
			gameObject2.GetComponent<RectTransform>().pivot = new Vector2(0.5f, 0.5f);
			gameObject2.GetComponent<RectTransform>().anchorMin = new Vector2(0.5f, 0f);
			gameObject2.GetComponent<RectTransform>().anchorMax = new Vector2(0.5f, 0f);
			gameObject2.GetComponent<RectTransform>().anchoredPosition = new Vector2(-20f, 173.8f);
			//Image image = gameObject2.AddComponent<Image>();
			//image.sprite = (Resources.GetBuiltinResource(typeof(Sprite), "InputFieldBackground") as Sprite);


			//image.raycastTarget = true;
			InputField inputField = gameObject2.AddComponent<InputField>();
			this.CoordinateField = inputField;
			inputField.interactable = true;
			inputField.transition = Selectable.Transition.ColorTint;
			inputField.textComponent = this.DebugObject;
			inputField.contentType = InputField.ContentType.Standard;
			inputField.lineType = InputField.LineType.SingleLine;
			inputField.caretBlinkRate = 0.85f;
			inputField.caretWidth = 1;
			inputField.shouldHideMobileInput = true;
			inputField.readOnly = false;


			GameObject ExitEditModeButton = new GameObject();
			ExitEditModeButton.transform.parent = inputField.transform;
			ExitEditModeButton.AddComponent<RectTransform>();
			ExitEditModeButton.layer = 5;
			ExitEditModeButton.AddComponent<RectTransform>();
			ExitEditModeButton.GetComponent<RectTransform>().pivot = new Vector2(0.5f, 0.5f);
			ExitEditModeButton.GetComponent<RectTransform>().anchorMin = new Vector2(0.5f, 0f);
			ExitEditModeButton.GetComponent<RectTransform>().anchorMax = new Vector2(0.5f, 0f);
			ExitEditModeButton.GetComponent<RectTransform>().anchoredPosition = new Vector2(-20f, 60);
			ExitEditModeButton.AddComponent<Image>();

			Button exitedit = ExitEditModeButton.AddComponent<Button>();
			exitedit.transition = Selectable.Transition.ColorTint;
			exitedit.targetGraphic = ExitEditModeButton.GetComponent<Image>();
			exitedit.interactable = true;
			exitedit.onClick.AddListener(delegate()
			{
				this.ExitEditMode();
			});



			gameObject2.transform.parent = gameObject.transform;
			this.DebugObject.transform.parent = gameObject2.transform;
			inputField.gameObject.SetActive(false);
			GameObject gameObject3 = new GameObject();
			gameObject3.transform.parent = gameObject.transform;
			gameObject3.layer = 5;
			gameObject3.AddComponent<RectTransform>();
			gameObject3.GetComponent<RectTransform>().pivot = new Vector2(0.5f, 0.5f);
			gameObject3.GetComponent<RectTransform>().anchorMin = new Vector2(1f, 1f);
			gameObject3.GetComponent<RectTransform>().anchorMax = new Vector2(1f, 1f);
			Image targetGraphic = gameObject3.AddComponent<Image>();
			gameObject3.GetComponent<RectTransform>().anchoredPosition = new Vector2(-128f, -122f);
			Button button = gameObject3.AddComponent<Button>();
			button.transition = Selectable.Transition.ColorTint;
			button.targetGraphic = targetGraphic;
			button.interactable = true;
			gameObject3.GetComponent<RectTransform>().anchoredPosition = new Vector2(-128f, -122f);
			Texture2D ico_pos = MFPEditorUtils.LoadPNG(MFPEditorUtils.LoadFileFromDataFolder("EditorAssets/icons/ico_position.png"));
			Sprite spr_pos = Sprite.Create(ico_pos, new Rect(0f, 0f, (float)ico_pos.width, (float)ico_pos.height), new Vector2(0f, 0f), 100f);
			targetGraphic.sprite = spr_pos;
			button.onClick.AddListener(delegate()
			{
				this.ChangeEditType("position");
			});
			GameObject gameObject6 = new GameObject();
			gameObject6.transform.parent = gameObject.transform;
			gameObject6.layer = 5;
			gameObject6.AddComponent<RectTransform>();
			gameObject6.GetComponent<RectTransform>().pivot = new Vector2(0.5f, 0.5f);
			gameObject6.GetComponent<RectTransform>().anchorMin = new Vector2(1f, 1f);
			gameObject6.GetComponent<RectTransform>().anchorMax = new Vector2(1f, 1f);
			Image targetGraphic2 = gameObject6.AddComponent<Image>();
			gameObject6.GetComponent<RectTransform>().anchoredPosition = new Vector2(-128f, -255.9f);
			Button button2 = gameObject6.AddComponent<Button>();
			Texture2D ico_rot = MFPEditorUtils.LoadPNG(MFPEditorUtils.LoadFileFromDataFolder("EditorAssets/icons/ico_rotation.png"));
			Sprite spr_rot = Sprite.Create(ico_rot, new Rect(0f, 0f, (float)ico_rot.width, (float)ico_rot.height), new Vector2(0f, 0f), 100f);
			targetGraphic2.sprite = spr_rot;
			button2.transition = Selectable.Transition.ColorTint;
			button2.targetGraphic = targetGraphic2;
			button2.interactable = true;
			button2.onClick.AddListener(delegate()
			{
				this.ChangeEditType("rotation");
			});
			GameObject gameObject7 = new GameObject();
			gameObject7.transform.parent = gameObject.transform;
			gameObject7.layer = 5;
			gameObject7.AddComponent<RectTransform>();
			gameObject7.GetComponent<RectTransform>().pivot = new Vector2(0.5f, 0.5f);
			gameObject7.GetComponent<RectTransform>().anchorMin = new Vector2(1f, 1f);
			gameObject7.GetComponent<RectTransform>().anchorMax = new Vector2(1f, 1f);
			Image targetGraphic3 = gameObject7.AddComponent<Image>();
			gameObject7.GetComponent<RectTransform>().anchoredPosition = new Vector2(-128f, -400f);
			Button button3 = gameObject7.AddComponent<Button>();
			Texture2D ico_sca = MFPEditorUtils.LoadPNG(MFPEditorUtils.LoadFileFromDataFolder("EditorAssets/icons/ico_scale.png"));
			Sprite spr_sca = Sprite.Create(ico_sca, new Rect(0f, 0f, (float)ico_sca.width, (float)ico_sca.height), new Vector2(0f, 0f), 100f);
			targetGraphic3.sprite = spr_sca;
			button3.transition = Selectable.Transition.ColorTint;
			button3.targetGraphic = targetGraphic3;
			button3.interactable = true;
			button3.onClick.AddListener(delegate()
			{
				this.ChangeEditType("scale");
			});
			GameObject gameObject4 = new GameObject();
			gameObject4.transform.parent = gameObject.transform;
			gameObject4.layer = 5;
			gameObject4.AddComponent<RectTransform>();
			gameObject4.GetComponent<RectTransform>().pivot = new Vector2(0.5f, 0.5f);
			gameObject4.GetComponent<RectTransform>().anchorMin = new Vector2(1f, 1f);
			gameObject4.GetComponent<RectTransform>().anchorMax = new Vector2(1f, 1f);
			gameObject4.AddComponent<Image>();
			gameObject4.GetComponent<RectTransform>().anchoredPosition = new Vector2(-128f, -550f);
			Button button4 = gameObject4.AddComponent<Button>();
			Texture2D ico_col = MFPEditorUtils.LoadPNG(MFPEditorUtils.LoadFileFromDataFolder("EditorAssets/icons/ico_color.png"));
			Sprite spr_col = Sprite.Create(ico_col, new Rect(0f, 0f, (float)ico_col.width, (float)ico_col.height), new Vector2(0f, 0f), 100f);
			gameObject4.GetComponent<Image>().sprite = spr_col;
			button4.transition = Selectable.Transition.ColorTint;
			button4.targetGraphic = gameObject4.GetComponent<Image>();
			button4.interactable = true;
			button4.onClick.AddListener(delegate()
			{
				this.ChangeEditType("color");
			});
			this.EditorButtonsRoot = new GameObject();
			this.EditorButtonsRoot.transform.parent = canvas.transform;
			gameObject3.transform.parent = this.EditorButtonsRoot.transform;
			gameObject4.transform.parent = this.EditorButtonsRoot.transform;
			gameObject7.transform.parent = this.EditorButtonsRoot.transform;
			gameObject6.transform.parent = this.EditorButtonsRoot.transform;
			GameObject PanelOBJ = new GameObject();
			PanelOBJ.transform.parent = gameObject.transform;
			PanelOBJ.name = "EntitiesListContainer";
			Image Panel = PanelOBJ.AddComponent<Image>();
			Panel.color = new Color(Panel.color.r, Panel.color.b, Panel.color.b, 0.3921569f);
			RectTransform component = PanelOBJ.GetComponent<RectTransform>();
			component.anchorMin = new Vector2(0.5f, 0.5f);
			component.anchorMax = new Vector2(0.5f, 0.5f);
			component.pivot = new Vector2(0.5f, 0.5f);
			component.sizeDelta = new Vector2(628.2f, 440.51f);
			component.anchoredPosition = new Vector2(0f, 0f);
			GameObject gameObject8 = new GameObject();
			gameObject8.name = "GasCanisterButton";
			gameObject8.transform.parent = PanelOBJ.transform;
			RectTransform rectTransform2 = gameObject8.AddComponent<RectTransform>();
			rectTransform2.anchorMin = new Vector2(0.5f, 0.5f);
			rectTransform2.anchorMax = new Vector2(0.5f, 0.5f);
			rectTransform2.pivot = new Vector2(0.5f, 0.5f);
			rectTransform2.sizeDelta = new Vector2(254.86f, 30f);
			rectTransform2.anchoredPosition = new Vector2(0f, 158f);
			Button gascanButton = gameObject8.AddComponent<Button>();
			Image gascanButtonGraphics = gascanButton.gameObject.AddComponent<Image>();
			gascanButton.targetGraphic = gascanButtonGraphics;

			gascanButton.onClick.AddListener(delegate()
			{
				this.SpawnEntity("gascanister");
			});

			GameObject gameObject9 = new GameObject();
			gameObject9.name = "GasCanisterButtonText";
			gameObject9.transform.parent = gascanButton.transform;
			RectTransform gascanButtonRect = gameObject9.AddComponent<RectTransform>();
			gascanButtonRect.anchorMin = new Vector2(0f, 0f);
			gascanButtonRect.anchorMax = new Vector2(1f, 1f);
			gascanButtonRect.pivot = new Vector2(0.5f, 0.5f);
			gascanButtonRect.anchoredPosition = new Vector2(0f, 0f);
			Text text2 = gameObject9.AddComponent<Text>();
			text2.font = (Resources.GetBuiltinResource(typeof(Font), "Arial.ttf") as Font);
			text2.text = "Gas Canister";
			text2.alignment = TextAnchor.MiddleCenter;
			gascanButtonRect.localScale = new Vector3(0.45943f, 0.45943f, 0.45943f);
			text2.color = new Color(0f, 0f, 0f);
			text2.fontSize = 64;
			text2.verticalOverflow = VerticalWrapMode.Overflow;
			text2.horizontalOverflow = HorizontalWrapMode.Overflow;
			this.EntitySpawnRoot = PanelOBJ;
			GameObject PanelOBJ2 = new GameObject();
			PanelOBJ2.transform.parent = gameObject.transform;
			PanelOBJ2.name = "WorldSettingsContainer";
			Image Panel2 = PanelOBJ2.AddComponent<Image>();
			Panel2.color = new Color(Panel2.color.r, Panel2.color.b, Panel2.color.b, 0.7f);
			RectTransform component2 = PanelOBJ2.GetComponent<RectTransform>();
			component2.anchorMin = new Vector2(0.5f, 0.5f);
			component2.anchorMax = new Vector2(0.5f, 0.5f);
			component2.pivot = new Vector2(0.5f, 0.5f);
			component2.sizeDelta = new Vector2(576.2f, 447.6f);
			component2.anchoredPosition = new Vector2(0f, 0f);
			GameObject gameObject10 = new GameObject();
			gameObject10.transform.parent = PanelOBJ2.transform;
			gameObject10.name = "AllowPostProcessText";
			RectTransform pptextrect = gameObject10.AddComponent<RectTransform>();
			pptextrect.anchorMin = new Vector2(0.5f, 0.5f);
			pptextrect.anchorMax = new Vector2(0.5f, 0.5f);
			pptextrect.pivot = new Vector2(0.5f, 0.5f);
			pptextrect.anchoredPosition = new Vector2(-216f, 187f);
			pptextrect.sizeDelta = new Vector2(160f, 30f);
			Text text3 = gameObject10.AddComponent<Text>();
			text3.font = (Resources.GetBuiltinResource(typeof(Font), "Arial.ttf") as Font);
			text3.text = "Allow Post Processing:";
			text3.alignment = TextAnchor.UpperLeft;
			pptextrect.localScale = new Vector3(0.49257f, 0.49257f, 0.49257f);
			text3.color = new Color(0f, 0f, 0f);
			text3.fontSize = 64;
			text3.verticalOverflow = VerticalWrapMode.Overflow;
			text3.horizontalOverflow = HorizontalWrapMode.Overflow;
			GameObject PostProcessingCheckmark = new GameObject();
			PostProcessingCheckmark.name = "PostProcessCheckmark";
			PostProcessingCheckmark.transform.parent = PanelOBJ2.transform;
			RectTransform rectTransform3 = PostProcessingCheckmark.AddComponent<RectTransform>();
			rectTransform3.pivot = new Vector2(0.5f, 0.5f);
			rectTransform3.anchorMin = new Vector2(0.5f, 0.5f);
			rectTransform3.anchorMax = new Vector2(0.5f, 0.5f);
			rectTransform3.sizeDelta = new Vector2(20.41f, 20f);
			rectTransform3.localScale = new Vector3(1.9014f, 1.9014f, 1.9014f);
			rectTransform3.anchoredPosition = new Vector2(97.5f, 175.6f);
			Toggle toggle = PostProcessingCheckmark.AddComponent<Toggle>();
			allowPostProcessToggle = toggle;
			toggle.isOn = true;
			GameObject checkmarkbg = new GameObject();
			checkmarkbg.name = "CheckmarkBackground";
			checkmarkbg.transform.parent = PostProcessingCheckmark.transform;
			RectTransform rectTransform4 = checkmarkbg.AddComponent<RectTransform>();
			rectTransform4.pivot = new Vector2(0.5f, 0.5f);
			rectTransform4.anchorMin = new Vector2(0f, 1f);
			rectTransform4.anchorMax = new Vector2(0f, 1f);
			rectTransform4.sizeDelta = new Vector2(20f, 20f);
			rectTransform4.anchoredPosition = new Vector2(10f, -10f);
			rectTransform4.localScale = new Vector3(1f, 1f, 1f);
			Image checkmarkbgGraphics = checkmarkbg.AddComponent<Image>();
			toggle.targetGraphic = checkmarkbgGraphics;
			RectTransform rectTransform5 = new GameObject
			{
				name = "Checkmark",
				transform = 
				{
					parent = checkmarkbg.transform
				}
			}.AddComponent<RectTransform>();
			rectTransform5.pivot = new Vector2(0.5f, 0.5f);
			rectTransform5.anchorMin = new Vector2(0.5f, 0.5f);
			rectTransform5.anchorMax = new Vector2(0.5f, 0.5f);
			rectTransform5.sizeDelta = new Vector2(20f, 20f);
			rectTransform5.anchoredPosition = new Vector2(0f, 0f);
			Image checkrectimage = rectTransform5.gameObject.AddComponent<Image>();
			Texture2D ico_check = MFPEditorUtils.LoadPNG(MFPEditorUtils.LoadFileFromDataFolder("EditorAssets/icons/checkmark.png"));
			Sprite spr_check = Sprite.Create(ico_check, new Rect(0f, 0f, (float)ico_check.width, (float)ico_check.height), new Vector2(0f, 0f), 100f);
			checkrectimage.sprite = spr_check;
			toggle.graphic = checkrectimage;
			this.WorldSettingsRoot = PanelOBJ2;
			this.WorldSettingsRoot.SetActive(false);
			GameObject gameObject11 = new GameObject();
			gameObject11.transform.parent = gameObject.transform;
			gameObject11.layer = 5;
			gameObject11.AddComponent<RectTransform>();
			gameObject11.GetComponent<RectTransform>().pivot = new Vector2(0.5f, 0.5f);
			gameObject11.GetComponent<RectTransform>().anchorMin = new Vector2(1f, 1f);
			gameObject11.GetComponent<RectTransform>().anchorMax = new Vector2(1f, 1f);
			gameObject11.AddComponent<Image>();
			gameObject11.GetComponent<RectTransform>().anchoredPosition = new Vector2(-128f, -700f);
			gameObject11.AddComponent<Button>().onClick.AddListener(delegate()
			{
				this.ToggleSettingsMenu("world", false);
			});

			toggle.onValueChanged.AddListener(delegate{AdjustPostProcessing(toggle.isOn, bloomIntensity, allowColorGrading, SkyColor, allowFog);});

	
			GameObject entitiesbutton = new GameObject();
			entitiesbutton.transform.parent = gameObject.transform;
			entitiesbutton.layer = 5;
			entitiesbutton.AddComponent<RectTransform>();
			entitiesbutton.GetComponent<RectTransform>().pivot = new Vector2(0.5f, 0.5f);
			entitiesbutton.GetComponent<RectTransform>().anchorMin = new Vector2(1f, 1f);
			entitiesbutton.GetComponent<RectTransform>().anchorMax = new Vector2(1f, 1f);
			entitiesbutton.AddComponent<Image>();
			entitiesbutton.GetComponent<RectTransform>().anchoredPosition = new Vector2(-128f, -850f);
			entitiesbutton.AddComponent<Button>().onClick.AddListener(delegate()
			{
				this.ToggleSettingsMenu("entities", false);
			});

			toggle.onValueChanged.AddListener(delegate{AdjustPostProcessing(toggle.isOn, bloomIntensity, allowColorGrading, SkyColor, allowFog);});

		
			GameObject AllowColorGradingTex = new GameObject();
			AllowColorGradingTex.transform.parent = PanelOBJ2.transform;
			AllowColorGradingTex.name = "AllowColorGradingText";

			RectTransform cgtextrect = AllowColorGradingTex.AddComponent<RectTransform>();
			cgtextrect.anchorMin = new Vector2(0.5f, 0.5f);
			cgtextrect.anchorMax = new Vector2(0.5f, 0.5f);
			cgtextrect.pivot = new Vector2(0.5f, 0.5f);
			cgtextrect.anchoredPosition = new Vector2(-235f, 125f);
			pptextrect.sizeDelta = new Vector2(160f, 30f);
			Text cgtext = AllowColorGradingTex.AddComponent<Text>();
			cgtext.font = (Resources.GetBuiltinResource(typeof(Font), "Arial.ttf") as Font);
			cgtext.text = "Allow Color Grading:";
			cgtext.alignment = TextAnchor.UpperLeft;
			cgtextrect.localScale = new Vector3(0.49257f, 0.49257f, 0.49257f);
			cgtext.color = new Color(0f, 0f, 0f);
			cgtext.fontSize = 64;
			cgtext.verticalOverflow = VerticalWrapMode.Overflow;
			cgtext.horizontalOverflow = HorizontalWrapMode.Overflow;


			GameObject ColorGradingCheckmark = new GameObject();
			ColorGradingCheckmark.name = "ColorGradingCheckmark";
			ColorGradingCheckmark.transform.parent = PanelOBJ2.transform;
			RectTransform colgradecheckrec = ColorGradingCheckmark.AddComponent<RectTransform>();
			colgradecheckrec.pivot = new Vector2(0.5f, 0.5f);
			colgradecheckrec.anchorMin = new Vector2(0.5f, 0.5f);
			colgradecheckrec.anchorMax = new Vector2(0.5f, 0.5f);
			colgradecheckrec.sizeDelta = new Vector2(20.41f, 20f);
			colgradecheckrec.localScale = new Vector3(1.9014f, 1.9014f, 1.9014f);
			colgradecheckrec.anchoredPosition = new Vector2(97.5f, 121.1f);
			Toggle colgradetoggle = ColorGradingCheckmark.AddComponent<Toggle>();
			allowColorGradingToggle = colgradetoggle;
			colgradetoggle.isOn = true;


			GameObject colgradingcheckmarkbg = new GameObject();
			colgradingcheckmarkbg.name = "CheckmarkBackground";
			colgradingcheckmarkbg.transform.parent = ColorGradingCheckmark.transform;
			RectTransform colgradcheckrect = colgradingcheckmarkbg.AddComponent<RectTransform>();
			colgradcheckrect.pivot = new Vector2(0.5f, 0.5f);
			colgradcheckrect.anchorMin = new Vector2(0f, 1f);
			colgradcheckrect.anchorMax = new Vector2(0f, 1f);
			colgradcheckrect.sizeDelta = new Vector2(20f, 20f);
			colgradcheckrect.anchoredPosition = new Vector2(10f, -10f);
			colgradcheckrect.localScale = new Vector3(1f, 1f, 1f);
			Image colgradecheckmarkbgGraphics = colgradingcheckmarkbg.AddComponent<Image>();
			colgradetoggle.targetGraphic = colgradecheckmarkbgGraphics;
			

			RectTransform colgraderect = new GameObject
			{
				name = "Checkmark",
				transform = 
				{
					parent = colgradingcheckmarkbg.transform
				}
			}.AddComponent<RectTransform>();
			colgraderect.pivot = new Vector2(0.5f, 0.5f);
			colgraderect.anchorMin = new Vector2(0.5f, 0.5f);
			colgraderect.anchorMax = new Vector2(0.5f, 0.5f);
			colgraderect.sizeDelta = new Vector2(20f, 20f);
			colgraderect.anchoredPosition = new Vector2(0f, 0f);
			Image colgradecheckrectimage = colgraderect.gameObject.AddComponent<Image>();

			colgradecheckrectimage.sprite = spr_check;
			colgradetoggle.graphic = colgradecheckrectimage;

			colgradetoggle.onValueChanged.AddListener(delegate{AdjustPostProcessing(allowPostProcess, bloomIntensity, colgradetoggle.isOn, SkyColor, allowFog);});
      
			gameObject11.transform.parent = this.EditorButtonsRoot.transform;
			
			entitiesbutton.transform.parent = this.EditorButtonsRoot.transform;

			EntitySpawnRoot.SetActive(false);


			MFPEditorLogger.Log("Hud load complete");
		}

		// Token: 0x0600061A RID: 1562
		public void EditingMode()
		{
			if (Input.GetKeyDown(KeyCode.L) && this.EditingObject != this.PlayerSpawn.gameObject && this.EditingObject != this.FinishLevelTrigger)
			{
				if(EditingObject.name.ToLower().Contains("wall"))
					{
					GeometryWallLump.Remove(EditingObject);
					}

				UnityEngine.Object.Destroy(this.EditingObject);
				this.Editing = false;
				this.EditingObject = null;
				this.CoordinateField.DeactivateInputField();
				this.CoordinateField.gameObject.SetActive(false);
			}
			bool isFocused = this.CoordinateField.isFocused;
			if (this.CoordinateField.isFocused)
			{
				if (this.editType != "position")
				{
					this.UpdateCoordinates(this.editType, this.CoordinateField.text);
					return;
				}
				this.ExitEditMode();
			}
			else
				{
					if(!this.CoordinateField.isFocused)
					{
					if(this.editType == "position")
					{
						CoordinateField.text = EditingObject.transform.position.ToString(); 
					}
					}
					else
					ExitEditMode();
				}
		}

		// Token: 0x0600061B RID: 1563
		public void UpdateCoordinates(string type, string coordinates)
		{
			if (this.EditingObject != null)
			{
				coordinates = coordinates.Replace("(", "");
				coordinates = coordinates.Replace(")", "");
				coordinates = coordinates.Replace(",", "");
				if (this.editType != "color")
				{
					float num = float.Parse(coordinates.Split(new char[]
					{
						' '
					})[0]);
					float num2 = float.Parse(coordinates.Split(new char[]
					{
						' '
					})[1]);
					float num3 = float.Parse(coordinates.Split(new char[]
					{
						' '
					})[2]);
					if(type == "position")
					{

						CoordinateField.text = coordinates;

					}

					if (type == "rotation")
					{

						this.EditingObject.transform.eulerAngles = new Vector3(num, num2, num3);
					}
					if (type == "scale")
					{

						if(num == 0)
							num = 0.001f;
						if(num2 == 0)
							num2 = 0.001f;
						if(num3 == 0)
							num3 = 0.001f;


						this.EditingObject.transform.localScale = new Vector3(num, num2, num3);
						return;
					}
				}
				else if (type == "color")
				{
					byte bit = Convert.ToByte(coordinates.Split(new char[]
					{
						' '
					})[0]);
					byte bit2 = Convert.ToByte(coordinates.Split(new char[]
					{
						' '
					})[1]);
					byte bit3 = Convert.ToByte(coordinates.Split(new char[]
					{
						' '
					})[2]);
					Color32 color255 = new Color32(bit, bit2, bit3, byte.MaxValue);
					MFPEditorLogger.Log(color255.ToString());
					this.EditingObject.GetComponent<MeshRenderer>().material.color = color255;
				}
			}
		}


		// Token: 0x0600061C RID: 1564
		public void ChangeEditType(string type)
		{

			if(SnapToBuild)
			{
				SnapToBuild = false;
				ToggleSnapping(false);
			}

			if(adjustingSettings)
				ToggleSettingsMenu(null, true);

			this.editType = type;

			
			if(Editing)
			{
				ExitEditMode();
				if(PreviousObject != null);
				EnterEditMode(PreviousObject);
			}

		}

		// Token: 0x0600061D RID: 1565
		public void EnterEditMode(GameObject gobject)
		{
			this.EditingObject = gobject;

			this.CoordinateField.gameObject.SetActive(true);
			if (this.editType != "position")
			{
				this.CoordinateField.ActivateInputField();
			}
			if (this.editType == "position")
			{
				this.CoordinateField.text = gobject.transform.position.ToString();
				gobject.GetComponent<MeshRenderer>().material = StandardShaderUtils.ChangeRenderMode(gobject.GetComponent<MeshRenderer>().material, StandardShaderUtils.BlendMode.Transparent);
				Color color = gobject.GetComponent<MeshRenderer>().material.color;
				color.a = 0.5f;
				this.ToggleEditingObjectColliders(gobject, false);
				Material material = new Material(Shader.Find("Standard"));
				gobject.GetComponent<MeshRenderer>().material.color = color;
				GameObject gameObject = new GameObject();
				gameObject.name = "AxeContainer";
				gameObject.transform.parent = gobject.transform;
				GameObject gameObject2 = new GameObject();
				gameObject2.AddComponent<MeshFilter>().mesh = this.EditorAxeMesh;
				gameObject2.AddComponent<MeshRenderer>();
				gameObject2.GetComponent<MeshRenderer>().material = material;
				gameObject2.GetComponent<MeshRenderer>().material.color = new Color(1f, 0f, 0f);
				gameObject2.transform.position = gobject.transform.position;
				gameObject2.transform.eulerAngles = new Vector3(0f, 90f, 0f);
				gameObject2.AddComponent<MeshCollider>().sharedMesh = this.EditorAxeMesh;
				gameObject2.GetComponent<MeshCollider>().convex = true;
				gameObject2.AddComponent<LevelEditorAxis>().axis = LevelEditorAxis.AxisType.x;
				gameObject2.name = "X Axis";
				GameObject gameObject3 = new GameObject();
				gameObject3.AddComponent<MeshFilter>().mesh = this.EditorAxeMesh;
				gameObject3.AddComponent<MeshRenderer>();
				gameObject3.GetComponent<MeshRenderer>().material = material;
				gameObject3.GetComponent<MeshRenderer>().material.color = new Color(0f, 1f, 0f);
				gameObject3.transform.position = gobject.transform.position;
				gameObject3.transform.eulerAngles = new Vector3(90f, 0f, 0f);
				gameObject3.AddComponent<MeshCollider>().sharedMesh = this.EditorAxeMesh;
				gameObject3.GetComponent<MeshCollider>().convex = true;
				gameObject3.AddComponent<LevelEditorAxis>().axis = LevelEditorAxis.AxisType.y;
				gameObject3.name = "Y Axis";
				GameObject gameObject4 = new GameObject();
				gameObject4.AddComponent<MeshFilter>().mesh = this.EditorAxeMesh;
				gameObject4.AddComponent<MeshRenderer>();
				gameObject4.GetComponent<MeshRenderer>().material = material;
				gameObject4.GetComponent<MeshRenderer>().material.color = new Color(0f, 0f, 1f);
				gameObject4.transform.position = gobject.transform.position;
				gameObject4.AddComponent<MeshCollider>().sharedMesh = this.EditorAxeMesh;
				gameObject4.GetComponent<MeshCollider>().convex = true;
				gameObject4.AddComponent<LevelEditorAxis>().axis = LevelEditorAxis.AxisType.z;
				gameObject4.name = "Z Axis";
				gameObject2.transform.parent = gameObject.transform;
				gameObject3.transform.parent = gameObject.transform;
				gameObject4.transform.parent = gameObject.transform;
				this.EditAxes = gameObject;
			}
			if (this.editType == "rotation")
			{
				if (this.EditingObject == this.PlayerSpawn.gameObject || this.EnemySpawnpoints.Contains(this.EditingObject.transform))
				{
					this.ExitEditMode();
					this.Editing = false;
				}
				this.CoordinateField.text = gobject.transform.eulerAngles.ToString();
			}
			if (this.editType == "scale")
			{
				if (this.EditingObject == this.PlayerSpawn.gameObject || this.EnemySpawnpoints.Contains(this.EditingObject.transform))
				{
					this.ExitEditMode();
					this.Editing = false;
				}
				this.CoordinateField.text = gobject.transform.localScale.ToString();
			}
			if (this.editType == "color")
			{
				if (this.EditingObject == this.PlayerSpawn.gameObject || this.EnemySpawnpoints.Contains(this.EditingObject.transform))
				{
					this.ExitEditMode();
					this.Editing = false;
				}

				Color32 Color255 = (Color32)gobject.GetComponent<MeshRenderer>().material.color;

				string totext255 = Color255.ToString();
				totext255 = totext255.Replace("RGBA", "");

				MFPEditorLogger.Log(totext255.ToString());
				this.CoordinateField.text = totext255;
			}
			this.Editing = true;
		}

		// Token: 0x0600061E RID: 1566
		public void PlayMode()
		{
			this.Player.transform.position = this.PlayerSpawn.transform.position;
			this.Player.GetComponent<Rigidbody>().velocity = new Vector3(0,0,0);
			DoMissingArrayCleanup();

			if (!this.PlayMod)
			{
				if (this.Editing)
				{
					this.ExitEditMode();
				}
				this.EditorButtonsRoot.SetActive(false);
				this.ToggleSettingsMenu(null, true);
				this.root.nrOfEnemiesTotal = 0;
				LevelEditorHandler.levelTimer = 0f;
				this.PlayerSpawn.GetComponent<CapsuleCollider>().enabled = false;
				this.PlayerSpawn.GetComponent<MeshRenderer>().enabled = false;
				this.Player.transform.position = this.PlayerSpawn.transform.position;
				this.HUD.GetComponentInChildren<Canvas>().enabled = true;
				this.Player.SetActive(true);
				this.Camera.SetActive(true);
				this.CoordinateField.DeactivateInputField();
				this.CoordinateField.gameObject.SetActive(false);
				this.EditorCamera.enabled = false;
				this.EditorCamera.transform.parent.GetComponent<CameraMovement>().enabled = false;
				this.PlayMod = true;
				TextureTilingController[] array = UnityEngine.Object.FindObjectsOfType<TextureTilingController>();
				for (int j = 0; j < array.Length; j++)
				{
					array[j].enabled = false;
				}
				foreach (Transform transform in this.EnemySpawnpoints)
				{
					transform.GetComponent<MeshRenderer>().enabled = false;
					transform.GetComponent<CapsuleCollider>().enabled = false;
					GameObject gameObject = UnityEngine.Object.Instantiate<GameObject>(this.EnemySample);
					this.Enemies.Add(gameObject);
					gameObject.transform.position = transform.position;
					this.root.nrOfEnemiesTotal++;
				}

				foreach(GameObject Canister in GasCanisters)
				{
					GameObject newCanister = Instantiate(GasCanister);
					newCanister.SetActive(true);

					newCanister.layer = 14;
					newCanister.AddComponent<Rigidbody>();
					newCanister.GetComponent<Rigidbody>().mass = 10;
					newCanister.GetComponent<Rigidbody>().drag = 0.1f;
					newCanister.GetComponent<Rigidbody>().angularDrag = 0.05f;

					newCanister.AddComponent<ObjectKickScript>().objType = 3;
					newCanister.AddComponent<GasCanisterScript>().explosionSize = 2;
					newCanister.GetComponent<ObjectKickScript>().bounceOnEnemyHit = true;
					newCanister.GetComponent<ObjectKickScript>().reactOnBulletHit = true;
					newCanister.AddComponent<AudioSource>();
					newCanister.AddComponent<PhysicsSoundsScript>();
					newCanister.AddComponent<AutoAimTargetScript>();
					newCanister.AddComponent<OptimizerScript>();

					LevelGasCanisters.Add(newCanister);

					Canister.SetActive(false);
				}

				this.FinishLevelTrigger.GetComponent<MeshRenderer>().enabled = false;
				this.FinishLevelTrigger.GetComponent<BoxCollider>().isTrigger = true;
				this.root.nrOfEnemiesTotal = this.root.nrOfEnemiesTotal / 2;
				this.root.nrOfEnemiesTotal -= this.root.nrOfEnemiesTotal;
				this.CalculateLevelHash();
				this.root.dontAllowCheckpointSave = true;
				return;
			}
			if (this.PlayMod)
			{
				this.EditorButtonsRoot.SetActive(true);
				LevelEditorHandler.levelTimer = 0f;
				this.Player.transform.position = this.PlayerSpawn.transform.position;
				this.PlayerSpawn.GetComponent<CapsuleCollider>().enabled = true;
				this.HUD.GetComponentInChildren<Canvas>().enabled = false;
				this.Player.SetActive(false);
				this.Camera.SetActive(false);
				this.EditorCamera.enabled = true;
				this.EditorCamera.transform.parent.GetComponent<CameraMovement>().enabled = true;
				this.PlayMod = false;
				foreach (GameObject obj in this.Enemies)
				{
					UnityEngine.Object.Destroy(obj);
				}
				TextureTilingController[] array2 = UnityEngine.Object.FindObjectsOfType<TextureTilingController>();
				for (int k = 0; k < array2.Length; k++)
				{
					array2[k].enabled = true;
				}
				foreach (Transform transform2 in this.EnemySpawnpoints)
				{
					transform2.gameObject.GetComponent<MeshRenderer>().enabled = true;
					transform2.gameObject.GetComponent<CapsuleCollider>().enabled = true;
				}

				foreach(GameObject Canister in GasCanisters)
					{

					Canister.SetActive(true);

					}

				foreach(GameObject LVCanister in LevelGasCanisters)
					{
						Destroy(LVCanister);
					}

				this.PlayerSpawn.GetComponent<MeshRenderer>().enabled = true;
				this.FinishLevelTrigger.GetComponent<MeshRenderer>().enabled = true;
				this.FinishLevelTrigger.GetComponent<BoxCollider>().isTrigger = false;
				this.Enemies.Clear();

				DoMissingArrayCleanup();
			}
		}

		// Token: 0x0600061F RID: 1567
		public void ExitEditMode()
		{
			string text = this.CoordinateField.text;
			this.CoordinateField.DeactivateInputField();
			this.CoordinateField.gameObject.SetActive(false);
			if (this.EditAxes != null)
			{
				UnityEngine.Object.Destroy(this.EditAxes);
				this.EditingObject.GetComponent<MeshRenderer>().material = StandardShaderUtils.ChangeRenderMode(this.EditingObject.GetComponent<MeshRenderer>().material, StandardShaderUtils.BlendMode.Opaque);
				Color color = this.EditingObject.GetComponent<MeshRenderer>().material.color;
				color.a = 1f;
				this.EditingObject.GetComponent<MeshRenderer>().material.color = color;
			}
			this.ToggleEditingObjectColliders(this.EditingObject, true);
			PreviousObject = EditingObject;
			this.EditingObject = null;
			this.Editing = false;
		}

		// Token: 0x06000620 RID: 1568
		public void LoadEditorAssets()
		{
			this.EditorAxeMesh = FastObjImporter.Instance.ImportFile(MFPEditorUtils.LoadFileFromDataFolder("EditorAssets/axe.obj"));
			this.DefaultTexture = MFPEditorUtils.LoadPNG(MFPEditorUtils.LoadFileFromDataFolder("EditorAssets/dev_measuregeneric01b.png"));
			string texname = MFPEditorUtils.LoadFileFromDataFolder("EditorAssets/dev_measuregeneric01b.png");
			texname = texname.Replace(MFPEditorUtils.LoadFileFromDataFolder(""), "");
			MFPEditorLogger.Log("Texture name is: " + texname);
			this.DefaultTexture.name = texname;

			DefaultStandardShader = new Material(Shader.Find("Standard"));
			
		}

		// Token: 0x06000621 RID: 1569
		public string LoadFileFromDataFolder(string file)
		{
			return Application.dataPath + "/LevelEditor_Jhrino/" + file;
		}

		// Token: 0x06000622 RID: 1570
		public void ToggleEditingObjectColliders(GameObject gobject, bool toggle)
		{
			if (gobject != null)
			{
				if (toggle)
				{
					gobject.GetComponent<Collider>();
					gobject.GetComponent<Collider>().enabled = true;
					return;
				}
				gobject.GetComponent<Collider>();
				gobject.GetComponent<Collider>().enabled = false;
			}
		}

		public void DoMissingArrayCleanup()
		{
				for (int i = this.EnemySpawnpoints.Count - 1; i > -1; i--)
			{
				if (this.EnemySpawnpoints[i] == null)
				{
					this.EnemySpawnpoints.RemoveAt(i);
				}
			}
			for (int j = this.GeometryWallLump.Count - 1; j > -1; j--)
			{
				if (this.GeometryWallLump[j] == null)
				{
					this.GeometryWallLump.RemoveAt(j);
				}
			}
			for (int j = this.GeometryFloorLump.Count - 1; j > -1; j--)
			{
				if (this.GeometryFloorLump[j] == null)
				{
					this.GeometryFloorLump.RemoveAt(j);
				}
			}

			for (int j = GasCanisters.Count - 1; j > -1; j--)
			{
				if (this.GasCanisters[j] == null)
				{
					this.GasCanisters.RemoveAt(j);
				}
			}

			
			for (int j = LevelGasCanisters.Count - 1; j > -1; j--)
			{
				if (this.LevelGasCanisters[j] == null)
				{
					this.LevelGasCanisters.RemoveAt(j);
				}
			}

			for (int j = this.BrushLump.Count - 1; j > -1; j--)
			{
				if (this.BrushLump[j] == null)
				{
					this.BrushLump.RemoveAt(j);
				}
			}

		}

		// Token: 0x06000623 RID: 1571
		public void PrototypeSave()
		{
			DoMissingArrayCleanup();

			List<string> SavedLevel = new List<string>();
			string item = this.PlayerSpawn.position.ToString().Replace("(", "").Replace(")", "").Replace(",", "");
			string item2 = this.FinishLevelTrigger.transform.position.ToString().Replace("(", "").Replace(")", "").Replace(",", "");
			SavedLevel.Add("!World");
			SavedLevel.Add("allowPostProcess = " + this.allowPostProcess.ToString());
			SavedLevel.Add("bloomIntensity = " + this.Camera.GetComponent<PostProcessingBehaviour>().profile.bloom.settings.bloom.intensity.ToString());
			SavedLevel.Add("allowColorGrading = " + this.allowColorGrading.ToString());
			SavedLevel.Add("theme = " + this.theme);
			SavedLevel.Add("SkyColor = " + BackgroundCamera.GetComponent<Camera>().backgroundColor.ToString().Replace("(", "").Replace(")", "").Replace(",", "").Replace("RGBA", ""));
			SavedLevel.Add("!Player");
			SavedLevel.Add(item);
			SavedLevel.Add("!LevelEnd");
			SavedLevel.Add(item2);
			SavedLevel.Add(this.FinishLevelTrigger.transform.localScale.ToString().Replace("(", "").Replace(")", "").Replace(",", ""));
			MFPEditorLogger.Log("player coordinates added");
			MFPEditorLogger.Log("----");
			int num = 2;
			while (this.EnemySpawnpoints.ElementAtOrDefault(num - 2) != null)
			{
				string text = this.EnemySpawnpoints[num - 2].transform.position.ToString().Replace("(", "").Replace(")", "").Replace(",", "");
				SavedLevel.Add("!EnemySpawn");
				SavedLevel.Add(text);
				MFPEditorLogger.Log("added coordinate " + text);
				num++;
			}
			MFPEditorLogger.Log("----");
			foreach (GameObject lump in this.GeometryWallLump)
			{
				SavedLevel.Add("!GeometryWall");
				SavedLevel.Add(lump.transform.position.ToString().Replace("(", "").Replace(")", "").Replace(",", ""));
				SavedLevel.Add(lump.transform.eulerAngles.ToString().Replace("(", "").Replace(")", "").Replace(",", ""));
				SavedLevel.Add(lump.transform.localScale.ToString().Replace("(", "").Replace(")", "").Replace(",", ""));
				SavedLevel.Add(lump.GetComponent<MeshRenderer>().material.color.ToString().Replace("(", "").Replace(")", "").Replace(",", "").Replace("RGBA", ""));
				SavedLevel.Add(lump.layer.ToString());
				SavedLevel.Add(lump.GetComponent<MeshRenderer>().material.mainTexture.name);
			}

			foreach (GameObject lump in this.GeometryFloorLump)
			{
				SavedLevel.Add("!GeometryFloor");
				SavedLevel.Add(lump.transform.position.ToString().Replace("(", "").Replace(")", "").Replace(",", ""));
				SavedLevel.Add(lump.transform.eulerAngles.ToString().Replace("(", "").Replace(")", "").Replace(",", ""));
				SavedLevel.Add(lump.transform.localScale.ToString().Replace("(", "").Replace(")", "").Replace(",", ""));
				SavedLevel.Add(lump.GetComponent<MeshRenderer>().material.color.ToString().Replace("(", "").Replace(")", "").Replace(",", "").Replace("RGBA", ""));
				SavedLevel.Add(lump.layer.ToString());
				SavedLevel.Add(lump.GetComponent<MeshRenderer>().material.mainTexture.name);
			}

			File.WriteAllLines(MFPEditorUtils.LoadFileFromDataFolder("Levels/default/level.txt"), SavedLevel.ToArray());
			this.CalculateLevelHash();
			MFPEditorLogger.Log("----");
		}

	public void ToggleSnapping(bool toggle)
	{
	  if(!toggle)
		{
			foreach(snaphelper snaphelping in GameObject.FindObjectsOfType<snaphelper>())
			{
				snaphelping.GetComponent<Collider>().enabled = false;
			}
		}
	  else
		{
			foreach(snaphelper snaphelping in GameObject.FindObjectsOfType<snaphelper>())
			{
				snaphelping.GetComponent<Collider>().enabled = true;
			}
		}
	}

		// Token: 0x06000624 RID: 1572
public void PrototypeLoad()
		{
			if (this.Editing)
			{
				this.ExitEditMode();
			}
			if(SnapToBuild)
			{
				ToggleSnapping(false);
			}

			string[] levelFile = File.ReadAllLines(MFPEditorUtils.LoadFileFromDataFolder("Levels/default/level.txt"));


			foreach (GameObject obj in this.BrushLump)
			{
				UnityEngine.Object.Destroy(obj);
			}
			foreach (GameObject obj in this.GeometryWallLump)
			{
				UnityEngine.Object.Destroy(obj);
			}

			foreach (GameObject obj in this.GeometryFloorLump)
			{
				UnityEngine.Object.Destroy(obj);
			}
			foreach (Transform transform in this.EnemySpawnpoints)
			{
				UnityEngine.Object.Destroy(transform.gameObject);
			}

			DoMissingArrayCleanup();

			MFPEditorLogger.Log("Loading File");
			MFPEditorLogger.Log("------------");
			string[] array = new string[]
			{
				"!Brush",
				"!GeometryWall",
				"!GeometryFloor",
				"!PlayerSpawn",
				"!EnemySpawn",
				"!LevelEnd"
			};
        for (int i = 0; i < levelFile.Length; i++) //WE'RE JUST GONNA READ THE WHOLE THING
        {
            String tag = levelFile[i]; //It SHOULD only hit this line if its a tag
            switch (tag)
            {
				case "!World":
					if(levelFile[i + 1].Contains ("True"))
					{
							allowPostProcess = true;
							MFPEditorLogger.Log("Post processing is enabled");
					}
					if(levelFile[i + 1].Contains("False"))
					{
							allowPostProcess = false;
							MFPEditorLogger.Log("Post processing is disabled");

					}
					float bloomIntensity = float.Parse(levelFile[i + 2].Replace("bloomIntensity = ", ""));


					if(levelFile[i + 3].Contains ("True"))
					{
							allowColorGrading = true;
							MFPEditorLogger.Log("Color grading is enabled");
					}
					if(levelFile[i + 3].Contains("False"))
					{
							allowColorGrading = false;
							MFPEditorLogger.Log("Color grading is disabled");

					}

					AdjustPostProcessing(allowPostProcess, bloomIntensity, allowColorGrading, SkyColor, allowFog);

					allowPostProcessToggle.isOn = allowPostProcess;
					allowColorGradingToggle.isOn = allowColorGrading;


					

					theme = int.Parse(levelFile[i + 4].Replace("theme = ", ""));
					root.theme = theme;

					float[] Skycolor = Array.ConvertAll(levelFile[i + 5].Replace("SkyColor = ", "").Split(new char[] { ' ' }), float.Parse);


					BackgroundCamera.GetComponent<Camera>().backgroundColor = new Color(Skycolor[0], Skycolor[1], Skycolor[2]);

				    SkyColor = BackgroundCamera.GetComponent<Camera>().backgroundColor;

					i += 5;
					break;

				case "!GeometryWall":

					MFPEditorLogger.Log("Data is about to get into memory");
					
			        float[] geowallposition = Array.ConvertAll(levelFile[i + 1].Split(new char[] { ' ' }), float.Parse);
                    float[] geowallrotation = Array.ConvertAll(levelFile[i + 2].Split(new char[] { ' ' }), float.Parse);
                    float[] geowallscale = Array.ConvertAll(levelFile[i + 3].Split(new char[] { ' ' }), float.Parse);
                    float[] geowallcolor = Array.ConvertAll(levelFile[i + 4].Split(new char[] { ' ' }), float.Parse);
                    int geowallproperty = int.Parse(levelFile[i + 5]);
                    string geowalltexturename = levelFile[i + 6];

					MFPEditorLogger.Log("Data in memory for brush");

                    GameObject newWall = Instantiate(wall_Brick);
					newWall.SetActive(true);
                    newWall.transform.position = new Vector3(geowallposition[0], geowallposition[1], geowallposition[2]);
                    newWall.transform.eulerAngles = new Vector3(geowallrotation[0], geowallrotation[1], geowallrotation[2]);
                    newWall.transform.localScale = new Vector3(geowallscale[0], geowallscale[1], geowallscale[2]);
                    newWall.GetComponent<MeshRenderer>().material.color = new Color(geowallcolor[0], geowallcolor[1], geowallcolor[2]);
					newWall.GetComponent<MeshRenderer>().material.mainTexture = MFPEditorUtils.LoadPNG(MFPEditorUtils.LoadFileFromDataFolder(geowalltexturename));
					string normalmap = geowalltexturename;
					geowalltexturename = geowalltexturename.Replace(".png", "");
					geowalltexturename = geowalltexturename + " _normal.png";
					newWall.GetComponent<MeshRenderer>().material.SetTexture("_BumpMap", MFPEditorUtils.LoadPNG(MFPEditorUtils.LoadFileFromDataFolder(normalmap)));
					newWall.GetComponent<MeshRenderer>().material.mainTexture.name = geowalltexturename;
					newWall.gameObject.layer = geowallproperty;
					GeometryWallLump.Add(newWall);
					i+= 6;
					break;
				
				case "!GeometryFloor":

				    float[] geofloorposition = Array.ConvertAll(levelFile[i + 1].Split(new char[] { ' ' }), float.Parse);
                    float[] geofloorrotation = Array.ConvertAll(levelFile[i + 2].Split(new char[] { ' ' }), float.Parse);
                    float[] geofloorscale = Array.ConvertAll(levelFile[i + 3].Split(new char[] { ' ' }), float.Parse);
                    float[] geofloorcolor = Array.ConvertAll(levelFile[i + 4].Split(new char[] { ' ' }), float.Parse);
                    int geofloorproperty = int.Parse(levelFile[i + 5]);
                    string geofloortexturename = levelFile[i + 6];

					MFPEditorLogger.Log("Data in memory for brush");

                    GameObject newFloor = Instantiate(floor_Wood);
					newFloor.SetActive(true);
                    newFloor.transform.position = new Vector3(geofloorposition[0], geofloorposition[1], geofloorposition[2]);
                    newFloor.transform.eulerAngles = new Vector3(geofloorrotation[0], geofloorrotation[1], geofloorrotation[2]);
                    newFloor.transform.localScale = new Vector3(geofloorscale[0], geofloorscale[1], geofloorscale[2]);
                    newFloor.GetComponent<MeshRenderer>().material.color = new Color(geofloorcolor[0], geofloorcolor[1], geofloorcolor[2]);
					newFloor.GetComponent<MeshRenderer>().material.mainTexture = MFPEditorUtils.LoadPNG(MFPEditorUtils.LoadFileFromDataFolder(geofloortexturename));
					newFloor.GetComponent<MeshRenderer>().material.mainTexture.name = geofloortexturename;
					string normalmap_floor = geofloortexturename;
					geofloortexturename = geofloortexturename.Replace(".png", "");
					geofloortexturename = geofloortexturename + " _normal.png";
					newFloor.GetComponent<MeshRenderer>().material.SetTexture("_BumpMap", MFPEditorUtils.LoadPNG(MFPEditorUtils.LoadFileFromDataFolder(normalmap_floor)));
					newFloor.gameObject.layer = geofloorproperty;
					GeometryFloorLump.Add(newFloor);
					i+= 6;
					
					break;

                case "!Brush": //ITS A BRUSH
                    //These basically just grab the correct line, split it into an array, and parse it to a float array in 1 line
                    float[] position = Array.ConvertAll(levelFile[i + 1].Split(new char[] { ' ' }), float.Parse);
                    float[] rotation = Array.ConvertAll(levelFile[i + 2].Split(new char[] { ' ' }), float.Parse);
                    float[] scale = Array.ConvertAll(levelFile[i + 3].Split(new char[] { ' ' }), float.Parse);
                    float[] color = Array.ConvertAll(levelFile[i + 4].Split(new char[] { ' ' }), float.Parse);
                    int property = int.Parse(levelFile[i + 5]);
                    string texturename = levelFile[i + 6];

                    GameObject newBrush = GameObject.CreatePrimitive(PrimitiveType.Cube);
                    newBrush.transform.position = new Vector3(position[0], position[1], position[2]);
                    newBrush.transform.rotation = new Quaternion(rotation[0], rotation[1], rotation[2], rotation[3]);
                    newBrush.transform.localScale = new Vector3(scale[0], scale[1], scale[2]);
                    newBrush.GetComponent<MeshRenderer>().material.color = new Color(color[0], color[1], color[2]);
					newBrush.GetComponent<MeshRenderer>().material.mainTexture = MFPEditorUtils.LoadPNG(MFPEditorUtils.LoadFileFromDataFolder(texturename));
					newBrush.GetComponent<MeshRenderer>().material.mainTexture.name = texturename;
					newBrush.AddComponent<TextureTilingController>();
                    newBrush.layer = property;
                    this.BrushLump.Add(newBrush);

                    i += 6;
                    break;

                case "!PlayerSpawn":
                    float[] playerposition = Array.ConvertAll(levelFile[i + 1].Split(new char[] { ' ' }), float.Parse);

                    this.PlayerSpawn.position = new Vector3(playerposition[0], playerposition[1], playerposition[2]);

                    i++;
                    break;

                case "!EnemySpawn":
                    float[] enemyposition = Array.ConvertAll(levelFile[i + 1].Split(new char[] { ' ' }), float.Parse);

                    GameObject gameObject3 = GameObject.CreatePrimitive(0);
                    Destroy(gameObject3.GetComponent<SphereCollider>());
                    gameObject3.AddComponent<CapsuleCollider>();
                    gameObject3.layer = 8;
                    gameObject3.transform.localScale = new Vector3(gameObject3.transform.localScale.x, 4f, gameObject3.transform.localScale.x);
                    gameObject3.transform.position = new Vector3(enemyposition[0], enemyposition[1], enemyposition[2]);
                    gameObject3.GetComponent<MeshRenderer>().material.color = new Color(1f, 0f, 0f);
                    this.EnemySpawnpoints.Add(gameObject3.transform);

                    i++;
                    break;

                case "!LevelEnd":
                    float[] finishposition = Array.ConvertAll(levelFile[i + 1].Split(new char[] { ' ' }), float.Parse);
					float[] finishscale = Array.ConvertAll(levelFile[i + 2].Split(new char[] { ' ' }), float.Parse);

                   this.FinishLevelTrigger.transform.position = new Vector3(finishposition[0], finishposition[1], finishposition[2]);
					this.FinishLevelTrigger.transform.localScale = new Vector3(finishscale[0], finishscale[1], finishscale[2]);
					

                    i += 2;
                    break;
            }
        }
			CalculateLevelHash();
			MFPEditorLogger.Log("Loading over");
			ToggleSnapping(false);
		}

		// Token: 0x06000625 RID: 1573
		private IEnumerator CheckVersion()
		{
			UnityWebRequest www = UnityWebRequest.Get("https://fronkln.github.io/MFPLevelEditor/version.txt");
			yield return www.SendWebRequest();
			if (www.isNetworkError)
			{
				MFPEditorLogger.Log("couldnt get web data");
			}
			else if (float.Parse(www.downloadHandler.text) != LevelEditorInfo.version)
			{
				Application.OpenURL("https://fronkln.github.io/MFPLevelEditor/outdated.html");
			}
			yield break;
		}

		// Token: 0x06000626 RID: 1574
		private void Awake()
		{
			base.StartCoroutine(this.CheckVersion());
			File.WriteAllLines(MFPEditorLogger.logfile, new string[0]);
			MFPEditorLogger.Log("--------LEVELEDITOR SESSION STARTED--------");
			MFPEditorLogger.Log(DateTime.Now.ToString("MM/dd/yyyy HH:mm"));
			MFPEditorLogger.Log("------------------------------------------");
		}


		public void SpawnEntity(string entity)
			{
				
				switch(entity)
				{
					default:
						MFPEditorLogger.Log("Invalid entity " + entity + '"');
					break;
					//TODO: Add saving and loading for gas canisters
					case "gascanister":
						GameObject newGasCanister = new GameObject();
						newGasCanister.AddComponent<MeshFilter>().mesh = FastObjImporter.Instance.ImportFile(MFPEditorUtils.LoadFileFromDataFolder("EditorAssets/BaseGame/GasCanister.obj"));
						newGasCanister.AddComponent<MeshRenderer>();
						newGasCanister.GetComponent<MeshRenderer>().material = new Material(DefaultStandardShader);
						newGasCanister.GetComponent<MeshRenderer>().material.mainTexture = MFPEditorUtils.LoadPNG(LoadFileFromDataFolder("EditorAssets/BaseGame/textures/texture_collection_1.png"));
						newGasCanister.transform.position = new Vector3(this.EditorCamera.transform.position.x, this.EditorCamera.transform.position.y, 0);
						newGasCanister.AddComponent<BoxCollider>();
					

						if(GasCanister == null)
						{
							GasCanister = Instantiate(newGasCanister);
						GasCanister.SetActive(false);
						}

						GasCanisters.Add(newGasCanister);
					
					break;
				}

			}

		// Token: 0x06000627 RID: 1575
		protected string GetMD5HashFromFile(string fileName)
		{
			string result;
			using (MD5 md5 = MD5.Create())
			{
				using (FileStream stream = File.OpenRead(fileName))
				{
					result = BitConverter.ToString(md5.ComputeHash(stream)).Replace("-", string.Empty);
				}
			}
			return result;
		}

		// Token: 0x06000628 RID: 1576
		public void CalculateLevelHash()
		{
			string text = LevelEditorHandler.RemoveExcessCharacters(new string((from c in this.GetMD5HashFromFile(MFPEditorUtils.LoadFileFromDataFolder("Levels/default/level.txt"))
			where char.IsDigit(c) || c == '.' || c == ','
			select c).ToArray<char>()), 16);
			MFPEditorLogger.Log(text);
			ulong hashnumb = ulong.Parse(text);
			hashnumb = hashnumb % 150000UL + 200UL;
			MFPEditorLogger.Log(hashnumb.ToString());
			LevelEditorHandler.levelHash = (int)hashnumb;
			MFPEditorLogger.Log(LevelEditorHandler.levelHash.ToString());
		}

		// Token: 0x06000629 RID: 1577
		static LevelEditorHandler()
		{
		}

		// Token: 0x0600062A RID: 1578
		public static string RemoveExcessCharacters(string value, int maxLen)
		{
			if (value.Length <= maxLen)
			{
				return value;
			}
			return value.Substring(0, maxLen);
		}

		// Token: 0x060006DC RID: 1756 
		public void AdjustPostProcessing(bool postProcessEnabled, float bloomIntensity, bool allowColorGrading, Color32 SkyColor, bool allowFog)
		{
			if (postProcessEnabled)
			{
				this.Camera.GetComponent<PostProcessingBehaviour>().enabled = true;
				this.EditorCamera.GetComponent<PostProcessingBehaviour>().enabled = true;
				MFPEditorLogger.Log("Post processing is adjusted to be enabled");

				Camera.GetComponent<PostProcessingBehaviour>().profile.colorGrading.enabled = allowColorGrading;
				this.allowColorGrading = allowColorGrading;

			}
			else
			{
				this.Camera.GetComponent<PostProcessingBehaviour>().enabled = false;
				this.EditorCamera.GetComponent<PostProcessingBehaviour>().enabled = false;
				MFPEditorLogger.Log("Post processing is adjusted to be disabled");
			}

			Camera.GetComponent<PostProcessingBehaviour>().profile.fog.enabled = allowFog;	

			this.allowPostProcess = postProcessEnabled;
			BloomModel.Settings custombloom = this.Camera.GetComponent<PostProcessingBehaviour>().profile.bloom.settings;
			custombloom.bloom.intensity = bloomIntensity;
			this.Camera.GetComponent<PostProcessingBehaviour>().profile.bloom.settings = custombloom;

			BackgroundCamera.GetComponent<Camera>().backgroundColor = SkyColor;

		}

		// Token: 0x06000703 RID: 1795


		public void ToggleSettingsMenu(string menuType, bool forceOff)
		{
			if(this.Editing)
				ExitEditMode();
			if(SnapToBuild)
				ToggleSnapping(false);

			if (forceOff)
			{
				this.WorldSettingsRoot.SetActive(false);
				this.EntitySpawnRoot.SetActive(false);
				this.adjustingSettings = false;
				return;
			}
			if (!this.adjustingSettings)
			{
				if (menuType == "world")
				{
					this.WorldSettingsRoot.SetActive(true);
					this.EntitySpawnRoot.SetActive(false);
				}
				if(menuType == "entities")
				{
					this.WorldSettingsRoot.SetActive(false);
					this.EntitySpawnRoot.SetActive(true);
				}

				this.adjustingSettings = true;
				return;
			}
			else
			{
				this.WorldSettingsRoot.SetActive(false);
				this.EntitySpawnRoot.SetActive(false);
				this.adjustingSettings = false;
			}
		}

		// Token: 0x04001338 RID: 4920
		public GameObject Player;

		// Token: 0x04001339 RID: 4921
		public GameObject Camera;
		public GameObject BackgroundCamera;
		// Token: 0x0400133A RID: 4922
		public GameObject HUD;

		// Token: 0x0400133B RID: 4923
		public GameObject RootShared;

		// Token: 0x0400133C RID: 4924
		public Camera EditorCamera;

		// Token: 0x0400133D RID: 4925
		public Text DebugObject;


		public GameObject EditingObject;
		public GameObject PreviousObject;

		// Token: 0x0400133F RID: 4927
		public InputField CoordinateField;

		// Token: 0x04001340 RID: 4928
		public bool Editing;

		// Token: 0x04001341 RID: 4929
		private string editType = "position";

		// Token: 0x04001342 RID: 4930
		public static LevelEditorHandler Inst;

		// Token: 0x04001343 RID: 4931
		public Transform PlayerSpawn;

		// Token: 0x04001344 RID: 4932
		public bool PlayMod;

		// Token: 0x04001345 RID: 4933
		public GameObject EnemySample;

		// Token: 0x04001346 RID: 4934
		public List<GameObject> Enemies = new List<GameObject>();

		// Token: 0x04001347 RID: 4935
		public List<Transform> EnemySpawnpoints = new List<Transform>();

		// Token: 0x04001348 RID: 4936
		public bool fart;

		// Token: 0x04001349 RID: 4937
		public GameObject FinishLevelTrigger;

		// Token: 0x0400134A RID: 4938
		public RootScript root;

		// Token: 0x0400134B RID: 4939
		public Mesh EditorAxeMesh;

		// Token: 0x0400134C RID: 4940
		public GameObject EditAxes;

		// Token: 0x0400134D RID: 4941
		public bool spawnpoints_saved;


		// Token: 0x0400134F RID: 4943
		public Texture2D DefaultTexture;

		// Token: 0x04001350 RID: 4944
		public GameObject EditorButtonsRoot;

		// Token: 0x04001351 RID: 4945
		public GameObject EntitySpawnRoot;

		// Token: 0x04001352 RID: 4946
		public int theme = 1;

		public bool allowPostProcess = true;
		public bool allowColorGrading = true;

		public bool allowFog = true;


		public bool SnapToBuild = false;

		// Token: 0x04001354 RID: 4948
		public static int levelHash = 55;

		// Token: 0x04001355 RID: 4949
		public static float levelTimer = 0f;

		// Token: 0x04001356 RID: 4950
		public static bool PlayerisDeadAndForceAutoLoad;

		// Token: 0x040013A2 RID: 5026
		public GameObject WorldSettingsRoot;

		// Token: 0x04001449 RID: 5193
		public bool adjustingSettings;

		// Token: 0x040014C3 RID: 5315
		public float bloomIntensity = 0.9f;
    
		public Color32 SkyColor;

		public Toggle allowPostProcessToggle;
		public Toggle allowColorGradingToggle;
//--------------------------------------------------LEGACY---------------------------------//
		public List<GameObject> BrushLump = new List<GameObject>();

//-----------------------------IMPROVED BUILDING DEPENDENCIES------------------------------//
		public GameObject SnapTarget;
			
		public List<GameObject> GeometryWallLump = new List<GameObject>();
		public List<GameObject> GeometryFloorLump = new List<GameObject>();

		public List<GameObject> GasCanisters = new List<GameObject>();
		public List<GameObject> LevelGasCanisters = new List<GameObject>();
	
		public GameObject floor_Wood;
		

		public GameObject wall_Brick;


		//------------------- PREVIEW OBJECTS-------------------//
		public GameObject GasCanister;

		//PRELOADED CONTENT
		public Material DefaultStandardShader;

//-------------------------------------------------------------------------------------------
		// Token: 0x020000E2 RID: 226
		public enum CameraMode
		{
			// Token: 0x04001358 RID: 4952
			Disabled,
			// Token: 0x04001359 RID: 4953
			Enabled
		}
	}
}